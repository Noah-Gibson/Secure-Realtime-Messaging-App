# Secure Instant Point-to-Point (P2P) Messaging Design Report
## Computer Security (C S-4173) Final Project
## The University of Oklahoma
### Noah Gibson
#### 5/4/2025
<br>

### Introduction and Stack
For the final project, I implemented the assigned secure instant messaging tool. The app is made using React TypeScript for the frontend and FastAPI Python for the backend. The React GUI allows the user to enter their information and send a message in real-time to another user in their web browser. The main features of the secure chat system are hashing the user’s message with the passphrase and a randomized salt, 256-bit encryption, secure transmission to the intended user, authentication, decryption, and responsive display of the received message in plaintext with its salt and ciphertext for demonstration purposes.

### GUI
The GUI features a section for the user to enter their information. This includes their chosen username and the agreed-upon passphrase by both parties. Each time the username input box changes, a new websocket is opened with the FastAPI backend server using that user’s name, and the previous one is closed. No other information is sent to the backend server at this point, including the passphrase, which is the secret between the sender (Alice) and the receiver (Bob). They decide on this passphrase outside of the app. A more polished version of the app should have a way of submitting the whole username at once so that fewer requests to the backend need to be made. There is also an area to enter the message recipient and message, along with a submit button.

### Salt Generation
The key derivation process begins once Alice enters her username, passphrase, recipient’s name, and message, and then presses the button to send her message. This starts with the salt generation. For this app, the salt is generated using the Web Crypto API’s secure random byte generation, and it is done for every message sent. The purpose of the salt is to add randomness to the key generation. It ensures that even with the same passphrase, a different key is used for every message. This means if the crypto key used for a given ciphertext between Alice and Bob were leaked, only that specific ciphertext can be decrypted. Every other message, past and future, remains secure as long as its keys remain secret.

### Key Derivation
Once a salt is generated, the app executes the deriveKey function, which takes in the user-inputted passphrase string as well as the dynamically generated salt string. It converts both of these to raw bytes and uses the Web Crypto API to hash these together with the PBKDF2 algorithm. The PBKDF2 algorithm in this app is set to use SHA-256 hashing, and it hashes the passphrase and salt over 100,000 iterations. 100,00 iterations is chosen to be a balance between security and performance. With that many iterations, the algorithm is expected to take roughly 100ms, which is fast for a user to compute occasionally but computationally expensive for an attacker to brute-force millions or billions of times. Once PBKDF2 is complete, the function returns a 256-bit long CryptoKey object ready to use AES-GCM encryption.

### Initialization Vector Generation
Next, an initialization vector (IV) is computed to be used for encryption. It does this using the Web Crypto API’s function to generate a new sequence of random bytes. The IV is pivotal because it introduces randomness to the ciphertext, similar to the salt’s purpose in the crypto key. This means if Alice sends the same plaintext message to Bob twice, the outputted ciphertext will be different, as shown below. This prevents frequency analysis attacks, where if an attacker intercepts many ciphertexts, they can use language analysis to correspond commonly used language in plaintext to its corresponding ciphertext.

### Encryption
Now, with the encryption key and IV ready, the app encrypts the plaintext into ciphertext using the AES-GCM algorithm, which uses the IV in addition to the encryption key to produce the encrypted ciphertext. AES-GCM is used, as opposed to other forms of AES, because it performs encryption and authentication at the same time. This is possible with the Galois Message Authentication Code (GMAC), which is a 16-byte tag computed using the ciphertext, crypto key, and IV. This tag is appended to the ciphertext. When Bob receives the ciphertext and tag, his app authenticates that it was sent by Alice by performing the same hashing algorithm using the received ciphertext, crypto key, and IV. If Bob’s GMAC matches the one sent by Alice, he continues. If it does not, an error is thrown, and the ciphertext is not decrypted. Additionally, the AES-GCM algorithm is designed so that it takes in an arbitrary number of bytes and does not require padding bytes to a specific block length.

### Data Transmission
Once Alice’s app has computed the ciphertext, it prepares the data and aggregates it into a payload. The payload contains the sender’s name (Alice), recipient’s name (Bob), IV, ciphertext, and salt, all formatted in JSON. An important point is that all of the hashing, encryption, and computation up to this point have been done locally in Alice’s browser, meaning that none of the sensitive data has been sent anywhere. The only data that has been sent is the name of the user to the backend server to open a websocket with that user. This ensures security because if the plaintext message had been sent to a server before this point, it would effectively be transmitted publicly. However, since the payload is now being sent to the backend server after encryption, it does not matter if it is intercepted because the ciphertext cannot be decrypted without the shared secret passphrase between Alice and Bob. When the backend server receives the JSON payload through the user’s websocket, it checks to see if the recipient listed in the payload (Bob) also has a connection. In this case, this just means another instance of the frontend is running, and that user has typed their name in as “Bob”. If Bob has a connection to the websocket, the payload is sent to him. An important note is that even if an attacker typed their name in as Bob and received the payload, they would not be able to decrypt it without the correct passphrase. The usernames’ only function in this app is convenience to avoid extra work for the backend server, so it is not broadcasting to every websocket connection for every payload it receives.

### Authentication and Decryption
Once Bob’s app frontend receives Alice’s JSON payload from the backend server, it generates Bob’s AES-GCM key using the received salt along with Bob’s locally-entered passphrase using the same PBKDF2 algorithm. It authenticates Alice as the real sender using the received IV with Bob’s AES-GCM key, as previously explained. If Bob’s GMAC does not match Alice’s, then the authentication fails, which happens if his passphrase is incorrect. This means that since authentication is successful, it is guaranteed that Bob has the correct passphrase. It then decrypts the ciphertext using the received IV and Bob’s AES-GCM key. The plaintext is now displayed on Bob’s screen dynamically using React.
